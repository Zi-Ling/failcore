# 设计哲学

本文档阐述 FailCore 的核心设计理念。

---

## 核心原则

### 1. 执行时保护

FailCore 专注于**执行时**的保护，而不是生成时。

**为什么：**
- 生成时的值可能看起来正确
- 执行时的值可能仍然错误
- 只有执行时才能确定实际行为

**示例：**
```python
# 生成时：路径看起来正确
path = "data/file.txt"

# 执行时：实际值可能是错误的
path = "/etc/passwd"  # 被阻止
```

### 2. 确定性保证

FailCore 提供**确定性**的保证，而不是概率性的。

**为什么：**
- 安全需要确定性
- 概率性保证不可靠
- 确定性保证可测试

**示例：**
```python
# 确定性：总是阻止
with run(policy="fs_safe") as ctx:
    write_file("/etc/passwd", "hack")  # 总是被阻止
```

### 3. 最小权限

FailCore 遵循**最小权限**原则。

**为什么：**
- 减少攻击面
- 降低风险
- 提高安全性

**示例：**
```python
# 只允许文件系统读取
with run(policy="fs_safe") as ctx:
    # 只允许读取，不允许写入
    read_file("data.txt")  # 允许
    write_file("output.txt", "data")  # 被阻止
```

### 4. 可审计性

FailCore 记录所有执行，提供**可审计性**。

**为什么：**
- 事后分析
- 合规要求
- 调试支持

**示例：**
```python
with run(policy="fs_safe") as ctx:
    write_file("test.txt", "Hello")
    
# 追踪文件包含完整记录
# - 工具调用
# - 策略决策
# - 执行结果
```

---

## 设计选择

### 1. 轻量级 vs 重量级

FailCore 选择**轻量级**：

- ✅ 无虚拟化
- ✅ 低开销
- ✅ 快速启动

**原因：**
- AI agent 需要频繁调用
- 性能至关重要
- 简单易于集成

### 2. 策略驱动 vs 硬编码

FailCore 选择**策略驱动**：

- ✅ 可配置
- ✅ 可扩展
- ✅ 可测试

**原因：**
- 不同场景需要不同规则
- 规则可能变化
- 需要灵活性

### 3. 声明式 vs 过程式

FailCore 选择**声明式**边界 + **过程式**策略：

- ✅ 边界：声明式（简单）
- ✅ 策略：过程式（灵活）

**原因：**
- 边界需要简单明确
- 策略需要复杂逻辑
- 平衡简单性和灵活性

---

## 架构原则

### 1. 单一职责

每个组件有单一职责：

- **Executor**：执行工具
- **Policy**：检查策略
- **Recorder**：记录追踪
- **Guardian**：成本控制

**优势：**
- 易于理解
- 易于测试
- 易于维护

### 2. 可组合性

组件可以组合使用：

```python
executor = Executor(
    policy=policy,
    recorder=recorder,
    cost_guardian=guardian
)
```

**优势：**
- 灵活性
- 可扩展性
- 可测试性

### 3. 可观测性

所有操作都可观测：

- 追踪文件
- 日志
- 指标

**优势：**
- 可调试
- 可审计
- 可分析

---

## 安全模型

### 1. 默认拒绝

FailCore 默认**拒绝**，除非明确允许：

```python
# 默认：拒绝所有操作
with run(policy="safe") as ctx:
    # 只有策略允许的操作才能执行
    pass
```

### 2. 最小权限

只授予**最小必要**权限：

```python
# 只允许文件系统读取
with run(policy="fs_safe") as ctx:
    # 写入被阻止
    pass
```

### 3. 深度防御

多层保护：

- 边界检查
- 策略检查
- 成本控制

**优势：**
- 即使一层失败，其他层仍能保护
- 提供冗余保护

---

## 性能考虑

### 1. 低开销

FailCore 的开销很小：

- 策略检查：< 1ms
- 追踪记录：异步
- 副作用检测：静态分析

**原因：**
- AI agent 需要频繁调用
- 性能至关重要

### 2. 快速失败

FailCore **快速失败**：

- 策略检查在执行前
- 违规立即阻止
- 不执行危险操作

**优势：**
- 减少资源浪费
- 快速反馈
- 降低风险

---

## 可扩展性

### 1. 插件系统

FailCore 支持插件：

- 自定义验证器
- 自定义策略
- 自定义中间件

**优势：**
- 可扩展
- 可定制
- 可集成

### 2. API 设计

FailCore 提供清晰的 API：

```python
# 简单 API
with run(policy="fs_safe") as ctx:
    @guard()
    def write_file(path: str, content: str):
        pass
```

**优势：**
- 易于使用
- 易于理解
- 易于集成

---

## 总结

FailCore 的设计哲学：

- ✅ **执行时保护**：在执行时检查，而不是生成时
- ✅ **确定性保证**：提供可预测的行为
- ✅ **最小权限**：只授予必要权限
- ✅ **可审计性**：记录所有执行
- ✅ **轻量级**：低开销，快速启动
- ✅ **可扩展**：支持插件和自定义

这些原则指导 FailCore 的开发和演进。

---

## 下一步

- [为什么不是 Docker](why-not-docker.md) - 了解设计选择
- [为什么不只是提示](why-not-only-prompt.md) - 了解设计理念
- [核心概念](../concepts/execution-boundary.md) - 深入了解实现
