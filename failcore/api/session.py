# failcore/api/session.py
"""
Session API - recommended main entry point for real usage
"""

from __future__ import annotations
from typing import Any, Callable, Dict, Optional
from ..core.step import Step, RunContext, StepResult, generate_step_id, generate_run_id
from ..core.executor.executor import Executor, ExecutorConfig
from ..core.tools.registry import ToolRegistry
from ..core.trace.recorder import JsonlTraceRecorder, NullTraceRecorder, TraceRecorder
from ..core.validate.validator import ValidatorRegistry
from ..core.policy.policy import Policy


class Session:
    """
    Session API - multiple calls within a single session
    
    Users can execute tools like running a script/workflow.
    
    Features:
    - session.call("tool", **params): execute one step
    - session.register("tool_name", fn): register a tool
    - Decorator-style tool registration supported
    - Failures don't raise exceptions: always returns structured result
    
    Example:
        >>> session = Session(trace="trace.jsonl")
        >>> session.register("divide", lambda a, b: a / b)
        >>> result = session.call("divide", a=6, b=2)
        >>> print(result.status, result.output.value)
    
    Decorator example:
        >>> session = Session()
        >>> @session.tool
        ... def add(a: int, b: int) -> int:
        ...     return a + b
        >>> result = session.call("add", a=1, b=2)
    """
    
    def __init__(
        self,
        trace: Optional[str] = None,
        validator: Optional[ValidatorRegistry] = None,
        policy: Optional[Policy] = None,
        sandbox: Optional[str] = None,
        run_id: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
    ):
        """
        Create a new execution session
        
        Args:
            trace: Optional trace file path (.jsonl), None for no recording
            validator: Optional validator registry (precondition/postcondition checks)
            policy: Optional policy (resource access, cost control, etc.)
            sandbox: Optional sandbox root directory (file operation restrictions)
            run_id: Optional run_id (auto-generated by default)
            tags: Optional tags (for trace filtering)
        """
        # Tool registry
        self._tools = ToolRegistry()
        
        # Create recorder
        self._recorder: TraceRecorder = JsonlTraceRecorder(trace) if trace else NullTraceRecorder()
        
        # Create executor
        self._executor = Executor(
            tools=self._tools,
            recorder=self._recorder,
            validator=validator,
            policy=policy,
            config=ExecutorConfig()
        )
        
        # Run context
        self._ctx = RunContext(
            run_id=run_id or generate_run_id(),
            sandbox_root=sandbox,
            tags=tags or {}
        )
        
        # Step counter (for generating step_id)
        self._step_counter = 0
    
    def register(self, name: str, fn: Callable[..., Any]) -> None:
        """
        Register a tool
        
        Args:
            name: Tool name
            fn: Tool function (callable)
        
        Example:
            >>> session.register("divide", lambda a, b: a / b)
        """
        self._tools.register(name, fn)
    
    def tool(self, fn: Callable[..., Any]) -> Callable[..., Any]:
        """
        Decorator-style tool registration (uses function name as tool name)
        
        Args:
            fn: Tool function
        
        Returns:
            Original function (unmodified)
        
        Example:
            >>> @session.tool
            ... def add(a: int, b: int) -> int:
            ...     return a + b
        """
        self._tools.register(fn.__name__, fn)
        return fn
    
    def call(self, tool: str, **params: Any) -> StepResult:
        """
        Call a tool
        
        Args:
            tool: Tool name
            **params: Tool parameters
        
        Returns:
            StepResult: Execution result (ok/fail + output/error)
        
        Example:
            >>> result = session.call("divide", a=6, b=2)
            >>> if result.status == "ok":
            ...     print(result.output.value)
        """
        # Generate step_id
        self._step_counter += 1
        step_id = f"s{self._step_counter:04d}"
        
        # Create step
        step = Step(
            id=step_id,
            tool=tool,
            params=params
        )
        
        # Execute
        result = self._executor.execute(step, self._ctx)
        
        return result
    
    def close(self) -> None:
        """
        Close session and cleanup resources
        
        Example:
            >>> session = Session(trace="trace.jsonl")
            >>> try:
            ...     session.call("divide", a=6, b=2)
            ... finally:
            ...     session.close()
        """
        if hasattr(self._recorder, 'close'):
            try:
                self._recorder.close()
            except Exception:
                pass
    
    def __enter__(self) -> Session:
        """Support context manager"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Support context manager"""
        self.close()
    
    @property
    def run_id(self) -> str:
        """Get current session's run_id"""
        return self._ctx.run_id
    
    @property
    def tools(self) -> ToolRegistry:
        """Get tool registry (advanced usage)"""
        return self._tools
