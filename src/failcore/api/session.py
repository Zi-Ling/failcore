# failcore/api/session.py
"""
Session API - recommended main entry point for real usage
"""

from __future__ import annotations
from typing import Any, Callable, Dict, Optional
from pathlib import Path
from datetime import datetime
from ..core.step import Step, RunContext, StepResult, generate_step_id, generate_run_id
from ..core.executor.executor import Executor, ExecutorConfig
from ..core.tools.registry import ToolRegistry
from ..core.tools.spec import ToolSpec
from ..core.tools.metadata import ToolMetadata
from ..core.tools.invoker import ToolInvoker
from ..core.trace.recorder import JsonlTraceRecorder, NullTraceRecorder, TraceRecorder
from ..core.validate.validator import ValidatorRegistry
from ..core.validate.rules import ValidationRuleSet
from ..core.validate.presets import ValidationPreset
from ..core.policy.policy import Policy


class Session:
    """
    Session API - multiple calls within a single session
    
    Users can execute tools like running a script/workflow.
    
    Features:
    - session.call("tool", **params): execute one step
    - session.register("tool_name", fn): register a tool
    - Decorator-style tool registration supported
    - Failures don't raise exceptions: always returns structured result
    
    Example:
        >>> session = Session(trace="trace.jsonl")
        >>> session.register("divide", lambda a, b: a / b)
        >>> result = session.call("divide", a=6, b=2)
        >>> print(result.status, result.output.value)
    
    Decorator example:
        >>> session = Session()
        >>> @session.tool
        ... def add(a: int, b: int) -> int:
        ...     return a + b
        >>> result = session.call("add", a=1, b=2)
    """
    
    def __init__(
        self,
        trace: Optional[str] = "auto",
        validator: Optional[ValidatorRegistry] = None,
        policy: Optional[Policy] = None,
        sandbox: Optional[str] = None,
        run_id: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        auto_ingest: bool = True,
    ):
        """
        Create a new execution session
        
        Args:
            trace: Trace file path (.jsonl). Options:
                - "auto" (default): Auto-generate path .failcore/runs/<date>/<run_id>_<time>/trace.jsonl
                - str: Custom path
                - None: Disable tracing
            validator: Optional validator registry (precondition/postcondition checks)
            policy: Optional policy (resource access, cost control, etc.)
            sandbox: Optional sandbox root directory (file operation restrictions)
            run_id: Optional run_id (auto-generated by default)
            tags: Optional tags (for trace filtering)
            auto_ingest: If True, automatically ingest trace to database on close (default: True)
        
        Example:
            >>> # Simplest usage - auto trace to .failcore/runs/ + auto ingest
            >>> session = Session()
            
            >>> # Custom trace path with auto ingest
            >>> session = Session(trace="my_trace.jsonl")
            
            >>> # No tracing
            >>> session = Session(trace=None)
            
            >>> # Disable auto ingest
            >>> session = Session(auto_ingest=False)
        """
        # Generate run_id first (needed for auto trace path)
        self._run_id = run_id or generate_run_id()
        
        # Sandbox validation (v0.1.2: enforce explicit sandbox for security)
        if sandbox is None:
            # Default to .failcore/sandbox for safety
            sandbox = ".failcore/sandbox"
            Path(sandbox).mkdir(parents=True, exist_ok=True)
        
        # Tool registry with sandbox support
        self._tools = ToolRegistry(sandbox_root=sandbox)
        
        # Validator registry (create if not provided)
        if validator is None:
            validator = ValidatorRegistry()
        self._validator = validator
        
        # Store auto_ingest flag
        self._auto_ingest = auto_ingest
        
        # Handle auto trace path
        # Use POSIX format (forward slashes) for cross-platform compatibility
        if trace == "auto":
            # Generate: .failcore/runs/<date>/<run_id>_<time>/trace.jsonl
            # Group by date to avoid too many directories in one folder
            now = datetime.now()
            date = now.strftime("%Y%m%d")
            time = now.strftime("%H%M%S")
            run_dir = Path(f".failcore/runs/{date}/{self._run_id}_{time}")
            run_dir.mkdir(parents=True, exist_ok=True)
            trace_path = (run_dir / "trace.jsonl").as_posix()
            self._recorder: TraceRecorder = JsonlTraceRecorder(trace_path)
            self._trace_path = trace_path
        elif trace is None:
            self._recorder: TraceRecorder = NullTraceRecorder()
            self._trace_path = None
        else:
            # Custom trace path - ensure directory exists
            trace_dir = Path(trace).parent
            if trace_dir != Path('.'):
                trace_dir.mkdir(parents=True, exist_ok=True)
            # Store path in POSIX format
            self._recorder: TraceRecorder = JsonlTraceRecorder(trace)
            self._trace_path = Path(trace).as_posix()
        
        # Create executor
        self._executor = Executor(
            tools=self._tools,
            recorder=self._recorder,
            validator=self._validator,
            policy=policy,
            config=ExecutorConfig()
        )
        
        # Run context - convert sandbox to relative path if absolute
        # Use POSIX format (forward slashes) for cross-platform compatibility
        sandbox_rel = None
        if sandbox:
            sandbox_path = Path(sandbox)
            if sandbox_path.is_absolute():
                try:
                    sandbox_rel = sandbox_path.relative_to(Path.cwd()).as_posix()
                except ValueError:
                    sandbox_rel = Path(sandbox).as_posix()
            else:
                sandbox_rel = Path(sandbox).as_posix()
        
        self._ctx = RunContext(
            run_id=self._run_id,
            sandbox_root=sandbox_rel,
            tags=tags or {}
        )
        
        # Step counter (for generating step_id)
        self._step_counter = 0
        
        # Create invoker (unified tool execution interface)
        # This is the entry point for all adapters
        self.invoker = ToolInvoker(self._executor, self._ctx)
        
        # Auto-register as the watch session
        from .watch import set_watch_session
        set_watch_session(self)
    
    def register(
        self,
        name: str,
        fn: Callable[..., Any],
        metadata: Optional[ToolMetadata] = None,
        description: str = "",
        auto_assemble: bool = True,
    ) -> None:
        """
        Register a tool with optional metadata
        
        Args:
            name: Tool name
            fn: Tool function (callable)
            metadata: Optional tool metadata (risk, side effect, policy)
            description: Optional tool description
            auto_assemble: Auto-assemble validation rules from metadata
        
        Example:
            >>> # Simple registration
            >>> session.register("divide", lambda a, b: a / b)
            
            >>> # With metadata
            >>> from failcore.core.tools.metadata import ToolMetadata, RiskLevel, SideEffect, DefaultPolicy
            >>> session.register(
            ...     "write_file",
            ...     write_file_fn,
            ...     metadata=ToolMetadata(
            ...         risk_level=RiskLevel.HIGH,
            ...         side_effect=SideEffect.WRITE,
            ...         default_policy=DefaultPolicy.BLOCK,
            ...     )
            ... )
        """
        if metadata is not None:
            # Register with full metadata support
            spec = ToolSpec(
                name=name,
                fn=fn,
                description=description,
                tool_metadata=metadata,
            )
            self._tools.register_tool(spec, auto_assemble=auto_assemble)
            
            # Sync validators to ValidatorRegistry for execution
            preconditions = self._tools.get_preconditions(name)
            postconditions = self._tools.get_postconditions(name)
            for precond in preconditions:
                self._validator.register_precondition(name, precond)
            for postcond in postconditions:
                self._validator.register_postcondition(name, postcond)
        else:
            # Simple registration (backward compatible)
            self._tools.register(name, fn)
    
    def bind_rules(self, tool_name: str, rules: ValidationRuleSet) -> None:
        """
        Bind validation rules to a tool
        
        Args:
            tool_name: Tool name
            rules: ValidationRuleSet with preconditions/postconditions
        
        Example:
            >>> from failcore.core.validate.rules import RuleAssembler
            >>> assembler = RuleAssembler(sandbox_root="/workspace")
            >>> rules = assembler.assemble(...)
            >>> session.bind_rules("write_file", rules)
        """
        # Register in ToolRegistry (for tracking)
        for precond in rules.preconditions:
            self._tools.register_precondition(tool_name, precond)
        for postcond in rules.postconditions:
            self._tools.register_postcondition(tool_name, postcond)
        
        # Also register in ValidatorRegistry (for execution)
        for precond in rules.preconditions:
            self._validator.register_precondition(tool_name, precond)
        for postcond in rules.postconditions:
            self._validator.register_postcondition(tool_name, postcond)
    
    def tool(self, fn: Callable[..., Any]) -> Callable[..., Any]:
        """
        Decorator-style tool registration (uses function name as tool name)
        
        Args:
            fn: Tool function
        
        Returns:
            Original function (unmodified)
        
        Example:
            >>> @session.tool
            ... def add(a: int, b: int) -> int:
            ...     return a + b
        """
        self._tools.register(fn.__name__, fn)
        return fn
    
    def call(self, tool: str, **params: Any) -> StepResult:
        """
        Call a tool
        
        Args:
            tool: Tool name
            **params: Tool parameters
        
        Returns:
            StepResult: Execution result (ok/fail + output/error)
        
        Example:
            >>> result = session.call("divide", a=6, b=2)
            >>> if result.status == "ok":
            ...     print(result.output.value)
        """
        # Generate step_id
        self._step_counter += 1
        step_id = f"s{self._step_counter:04d}"
        
        # Create step
        step = Step(
            id=step_id,
            tool=tool,
            params=params
        )
        
        # Execute
        result = self._executor.execute(step, self._ctx)
        
        return result
    
    def close(self) -> None:
        """
        Close session and cleanup resources
        
        If auto_ingest=True, automatically ingests trace to database.
        
        Example:
            >>> session = Session(trace="trace.jsonl")
            >>> try:
            ...     session.call("divide", a=6, b=2)
            ... finally:
            ...     session.close()
        """
        # Close recorder first to flush trace
        if hasattr(self._recorder, 'close'):
            try:
                self._recorder.close()
            except Exception:
                pass
        
        # Auto-ingest trace to database
        if self._auto_ingest and self._trace_path:
            self._ingest_trace()
    
    def _ingest_trace(self) -> None:
        """
        Internal method: Ingest trace to database.
        
        This is called automatically if auto_ingest=True.
        Failures are silently logged to avoid breaking session cleanup.
        """
        try:
            from ..infra.storage import SQLiteStore, TraceIngestor
            
            # Check if trace file exists and has content
            if not Path(self._trace_path).exists():
                return
            
            file_size = Path(self._trace_path).stat().st_size
            if file_size == 0:
                return
            
            # Default database path
            db_path = ".failcore/failcore.db"
            
            # Ensure directory exists
            Path(".failcore").mkdir(exist_ok=True)
            
            # Ingest trace
            with SQLiteStore(db_path) as store:
                store.init_schema()
                ingestor = TraceIngestor(store)
                stats = ingestor.ingest_file(self._trace_path, skip_if_exists=True)
                
                # Silently succeed - trace ingested
        
        except ImportError:
            # Storage module not available - skip silently
            pass
        except Exception as e:
            # Don't fail session close due to ingest errors
            # Users can manually ingest later if needed
            import sys
            if hasattr(sys, 'stderr'):
                print(f"Warning: Failed to auto-ingest trace: {e}", file=sys.stderr)
    
    def __enter__(self) -> Session:
        """Support context manager"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Support context manager"""
        self.close()
    
    @property
    def run_id(self) -> str:
        """Get current session's run_id"""
        return self._ctx.run_id
    
    @property
    def tools(self) -> ToolRegistry:
        """Get tool registry (advanced usage)"""
        return self._tools
