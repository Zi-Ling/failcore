# failcore/api/session.py
"""
Session API - recommended main entry point for real usage
"""

from __future__ import annotations
from typing import Any, Callable, Dict, Optional
from pathlib import Path
from datetime import datetime
from ..core.step import Step, RunContext, StepResult, generate_step_id, generate_run_id
from ..core.executor.executor import Executor, ExecutorConfig
from ..core.tools.registry import ToolRegistry
from ..core.tools.invoker import ToolInvoker
from ..core.trace.recorder import JsonlTraceRecorder, NullTraceRecorder, TraceRecorder
from ..core.validate.validator import ValidatorRegistry
from ..core.policy.policy import Policy


class Session:
    """
    Session API - multiple calls within a single session
    
    Users can execute tools like running a script/workflow.
    
    Features:
    - session.call("tool", **params): execute one step
    - session.register("tool_name", fn): register a tool
    - Decorator-style tool registration supported
    - Failures don't raise exceptions: always returns structured result
    
    Example:
        >>> session = Session(trace="trace.jsonl")
        >>> session.register("divide", lambda a, b: a / b)
        >>> result = session.call("divide", a=6, b=2)
        >>> print(result.status, result.output.value)
    
    Decorator example:
        >>> session = Session()
        >>> @session.tool
        ... def add(a: int, b: int) -> int:
        ...     return a + b
        >>> result = session.call("add", a=1, b=2)
    """
    
    def __init__(
        self,
        trace: Optional[str] = "auto",
        validator: Optional[ValidatorRegistry] = None,
        policy: Optional[Policy] = None,
        sandbox: Optional[str] = None,
        run_id: Optional[str] = None,
        tags: Optional[Dict[str, str]] = None,
        auto_ingest: bool = True,
    ):
        """
        Create a new execution session
        
        Args:
            trace: Trace file path (.jsonl). Options:
                - "auto" (default): Auto-generate path .failcore/runs/<date>/<run_id>_<time>/trace.jsonl
                - str: Custom path
                - None: Disable tracing
            validator: Optional validator registry (precondition/postcondition checks)
            policy: Optional policy (resource access, cost control, etc.)
            sandbox: Optional sandbox root directory (file operation restrictions)
            run_id: Optional run_id (auto-generated by default)
            tags: Optional tags (for trace filtering)
            auto_ingest: If True, automatically ingest trace to database on close (default: True)
        
        Example:
            >>> # Simplest usage - auto trace to .failcore/runs/ + auto ingest
            >>> session = Session()
            
            >>> # Custom trace path with auto ingest
            >>> session = Session(trace="my_trace.jsonl")
            
            >>> # No tracing
            >>> session = Session(trace=None)
            
            >>> # Disable auto ingest
            >>> session = Session(auto_ingest=False)
        """
        # Generate run_id first (needed for auto trace path)
        self._run_id = run_id or generate_run_id()
        
        # Tool registry
        self._tools = ToolRegistry()
        
        # Store auto_ingest flag
        self._auto_ingest = auto_ingest
        
        # Handle auto trace path
        # Use POSIX format (forward slashes) for cross-platform compatibility
        if trace == "auto":
            # Generate: .failcore/runs/<date>/<run_id>_<time>/trace.jsonl
            # Group by date to avoid too many directories in one folder
            now = datetime.now()
            date = now.strftime("%Y%m%d")
            time = now.strftime("%H%M%S")
            run_dir = Path(f".failcore/runs/{date}/{self._run_id}_{time}")
            run_dir.mkdir(parents=True, exist_ok=True)
            trace_path = (run_dir / "trace.jsonl").as_posix()
            self._recorder: TraceRecorder = JsonlTraceRecorder(trace_path)
            self._trace_path = trace_path
        elif trace is None:
            self._recorder: TraceRecorder = NullTraceRecorder()
            self._trace_path = None
        else:
            # Custom trace path - ensure directory exists
            trace_dir = Path(trace).parent
            if trace_dir != Path('.'):
                trace_dir.mkdir(parents=True, exist_ok=True)
            # Store path in POSIX format
            self._recorder: TraceRecorder = JsonlTraceRecorder(trace)
            self._trace_path = Path(trace).as_posix()
        
        # Create executor
        self._executor = Executor(
            tools=self._tools,
            recorder=self._recorder,
            validator=validator,
            policy=policy,
            config=ExecutorConfig()
        )
        
        # Run context - convert sandbox to relative path if absolute
        # Use POSIX format (forward slashes) for cross-platform compatibility
        sandbox_rel = None
        if sandbox:
            sandbox_path = Path(sandbox)
            if sandbox_path.is_absolute():
                try:
                    sandbox_rel = sandbox_path.relative_to(Path.cwd()).as_posix()
                except ValueError:
                    sandbox_rel = Path(sandbox).as_posix()
            else:
                sandbox_rel = Path(sandbox).as_posix()
        
        self._ctx = RunContext(
            run_id=self._run_id,
            sandbox_root=sandbox_rel,
            tags=tags or {}
        )
        
        # Step counter (for generating step_id)
        self._step_counter = 0
        
        # Create invoker (unified tool execution interface)
        # This is the entry point for all adapters
        self.invoker = ToolInvoker(self._executor, self._ctx)
        
        # Auto-register as the watch session
        from .watch import set_watch_session
        set_watch_session(self)
    
    def register(self, name: str, fn: Callable[..., Any]) -> None:
        """
        Register a tool
        
        Args:
            name: Tool name
            fn: Tool function (callable)
        
        Example:
            >>> session.register("divide", lambda a, b: a / b)
        """
        self._tools.register(name, fn)
    
    def tool(self, fn: Callable[..., Any]) -> Callable[..., Any]:
        """
        Decorator-style tool registration (uses function name as tool name)
        
        Args:
            fn: Tool function
        
        Returns:
            Original function (unmodified)
        
        Example:
            >>> @session.tool
            ... def add(a: int, b: int) -> int:
            ...     return a + b
        """
        self._tools.register(fn.__name__, fn)
        return fn
    
    def call(self, tool: str, **params: Any) -> StepResult:
        """
        Call a tool
        
        Args:
            tool: Tool name
            **params: Tool parameters
        
        Returns:
            StepResult: Execution result (ok/fail + output/error)
        
        Example:
            >>> result = session.call("divide", a=6, b=2)
            >>> if result.status == "ok":
            ...     print(result.output.value)
        """
        # Generate step_id
        self._step_counter += 1
        step_id = f"s{self._step_counter:04d}"
        
        # Create step
        step = Step(
            id=step_id,
            tool=tool,
            params=params
        )
        
        # Execute
        result = self._executor.execute(step, self._ctx)
        
        return result
    
    def close(self) -> None:
        """
        Close session and cleanup resources
        
        If auto_ingest=True, automatically ingests trace to database.
        
        Example:
            >>> session = Session(trace="trace.jsonl")
            >>> try:
            ...     session.call("divide", a=6, b=2)
            ... finally:
            ...     session.close()
        """
        # Close recorder first to flush trace
        if hasattr(self._recorder, 'close'):
            try:
                self._recorder.close()
            except Exception:
                pass
        
        # Auto-ingest trace to database
        if self._auto_ingest and self._trace_path:
            self._ingest_trace()
    
    def _ingest_trace(self) -> None:
        """
        Internal method: Ingest trace to database.
        
        This is called automatically if auto_ingest=True.
        Failures are silently logged to avoid breaking session cleanup.
        """
        try:
            from ..infra.storage import SQLiteStore, TraceIngestor
            
            # Check if trace file exists and has content
            if not Path(self._trace_path).exists():
                return
            
            file_size = Path(self._trace_path).stat().st_size
            if file_size == 0:
                return
            
            # Default database path
            db_path = ".failcore/failcore.db"
            
            # Ensure directory exists
            Path(".failcore").mkdir(exist_ok=True)
            
            # Ingest trace
            with SQLiteStore(db_path) as store:
                store.init_schema()
                ingestor = TraceIngestor(store)
                stats = ingestor.ingest_file(self._trace_path, skip_if_exists=True)
                
                # Silently succeed - trace ingested
        
        except ImportError:
            # Storage module not available - skip silently
            pass
        except Exception as e:
            # Don't fail session close due to ingest errors
            # Users can manually ingest later if needed
            import sys
            if hasattr(sys, 'stderr'):
                print(f"Warning: Failed to auto-ingest trace: {e}", file=sys.stderr)
    
    def __enter__(self) -> Session:
        """Support context manager"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Support context manager"""
        self.close()
    
    @property
    def run_id(self) -> str:
        """Get current session's run_id"""
        return self._ctx.run_id
    
    @property
    def tools(self) -> ToolRegistry:
        """Get tool registry (advanced usage)"""
        return self._tools
